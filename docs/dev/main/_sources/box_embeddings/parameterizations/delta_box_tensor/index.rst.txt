:mod:`box_embeddings.parameterizations.delta_box_tensor`
========================================================

.. py:module:: box_embeddings.parameterizations.delta_box_tensor

.. autoapi-nested-parse::

   Implementation of min-delta box parameterization.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   box_embeddings.parameterizations.delta_box_tensor.MinDeltaBoxTensor



.. class:: MinDeltaBoxTensor(data: Union[(torch.Tensor, Tuple[torch.Tensor, torch.Tensor])], beta: float = 1.0, threshold: float = 20)


   Bases: :class:`box_embeddings.parameterizations.box_tensor.BoxTensor`

   Unconstrained min-delta box tensor.

   For input of the shape (..., 2, box_dim), this parameterization
   defines z=w, and Z=w + delta, where w and delta come from the -2th dimension
   of the input. It uses softplus to keep the delta positive.

   .. attribute:: w2z_ratio
      :annotation: :int = 2

      

   .. method:: kwargs(self) -> Dict
      :property:

      Configuration attribute values

      :returns: Dict


   .. method:: args(self) -> Tuple
      :property:


   .. method:: Z(self) -> torch.Tensor
      :property:

      Top right coordinate as Tensor

      :returns: top right corner
      :rtype: Tensor


   .. method:: W(cls: Type[TBoxTensor], z: torch.Tensor, Z: torch.Tensor, beta: float = 1.0, threshold: float = 20.0) -> torch.Tensor
      :classmethod:

      Given (z,Z), it returns one set of valid box weights W, such that
      Box(W) = (z,Z).

      The min coordinate is stored as is:
      W[...,0,:] = z
      W[...,1,:] = softplus_inverse(Z-z)

      The max coordinate is transformed


      :param z: Lower left coordinate of shape (..., hidden_dims)
      :param Z: Top right coordinate of shape (..., hidden_dims)
      :param beta: TODO
      :param threshold: TODO

      :returns:

                Parameters of the box. In base class implementation, this
                    will have shape (..., 2, hidden_dims).
      :rtype: Tensor


   .. method:: from_vector(cls, vector: torch.Tensor, beta: float = 1.0, threshold: float = 20) -> box_embeddings.parameterizations.box_tensor.BoxTensor
      :classmethod:

      Creates a box for a vector. In this base implementation the vector is split
      into two pieces and these are used as z and delta.

      :param vector: tensor
      :param beta: beta parameter for softplus for delta. Depending on the
                   universe box and your inputs ranges, you might want to change this.
                   Higher values of beta will make softplus harder and bring it close to ReLU.
      :param threshold: parameter for the softplus for delta

      :returns: A BoxTensor

      :raises ValueError: if last dimension is not even


   .. method:: reinit(self, data: Union[(Tensor, Tuple[Tensor, Tensor])]) -> None


   .. method:: z(self) -> torch.Tensor
      :property:

      Lower left coordinate as Tensor

      :returns: lower left corner
      :rtype: Tensor


   .. method:: centre(self) -> torch.Tensor
      :property:

      Centre coordinate as Tensor

      :returns: Center
      :rtype: Tensor


   .. method:: check_if_valid_zZ(cls: Type[TBoxTensor], z: torch.Tensor, Z: torch.Tensor) -> None
      :classmethod:

      Check of (z,Z) form a valid box.

      If your child class parameterization bounds the boxes to some universe
      box then this is the right place to check that.

      :param z: Lower left coordinate of shape (..., hidden_dims)
      :param Z: Top right coordinate of shape (..., hidden_dims)

      :raises ValueError: If `z` and `Z` do not have the same shape
      :raises ValueError: If `Z` < `z`


   .. method:: zZ_to_embedding(cls, z: torch.Tensor, Z: torch.Tensor, *args: Any, **kwargs: Any) -> torch.Tensor
      :classmethod:


   .. method:: from_zZ(cls: Type[TBoxTensor], z: torch.Tensor, Z: torch.Tensor, *args: Any, **kwargs: Any) -> TBoxTensor
      :classmethod:

      Creates a box for the given min-max coordinates (z,Z).

      In the this base implementation we do this by
      stacking z and Z along -2 dim to form W.

      :param z: lower left
      :param Z: top right
      :param \*args: extra arguments for child class
      :param \*\*kwargs: extra arguments for child class

      :returns: A BoxTensor


   .. method:: like_this_from_zZ(self, z: torch.Tensor, Z: torch.Tensor) -> box_embeddings.parameterizations.box_tensor.BoxTensor

      Creates a box for the given min-max coordinates (z,Z).
      This is similar to the class method :method:`from_zZ`, but
      uses the attributes on self and not external args, kwargs.

      For the base class, since we do not have extra attributes,
      we simply call from_zZ.


      :param z: lower left
      :param Z: top right

      :returns: A BoxTensor


   .. method:: box_shape(self) -> Tuple
      :property:

      Shape of z, Z and center.

      :returns: Shape of z, Z and center.

      .. note:: This is *not* the shape of the `data` attribute.


   .. method:: broadcast(self, target_shape: Tuple) -> None

      Broadcasts the internal data member in-place such that z and Z
      return tensors that can be automatically broadcasted to perform
      arithmetic operations with shape `target_shape`.

      Ex:
          target_shape = (4,5,10)

          1. self.box_shape = (10,) => (1,1,10)
          2. self.box_shape = (3,) => ValueError
          3. self.box_shape = (4,10) => (4,1,10)
          4. self.box_shape = (4,2,10) =>  ValueError
          5. self.box_shape = (5,10) => (1,5,10)

      .. note::

         This operation will not result in self.z, self.Z and self.center returning
         tensor of shape `target_shape` but it will result in return a tensor
         which is arithmetic compatible with `target_shape`.

      :param target_shape: Shape of the broadcast target. Usually will be the shape of
                           the tensor you wish to use z, Z with. For instance, if you wish to
                           add self box's center [shape=(batch, hidden_dim)] with other
                           box whose center's shape is (batch, extra_dim, hidden_dim), then
                           this function will reshape the data such that the resulting center
                           has shape (batch, 1, hidden_dim).

      :raises ValueError: If bad target

      ..todo::
          Add an extra argument `repeat` which tell the
          function to repeat values till target is satisfied.
          This is needed for gumbel_intersection, where the broadcasted
          tensors need to be stacked.


   .. method:: box_reshape(self, target_shape: Tuple) -> box_embeddings.parameterizations.box_tensor.BoxTensor

      Reshape the z,Z and center.

      Ex:
          1. self.box_shape = (5,10), target_shape = (-1,10), creates box_shape (5,10)
          2. self.box_shape = (5,4,10), target_shape = (-1,10), creates box_shape (20,10)
          4. self.box_shape = (20,10), target_shape = (10,2,10), creates box_shape (10,2,10)
          3. self.box_shape = (5,), target_shape = (-1,10),  raises RuntimeError
          5. self.box_shape = (5,10), target_shape = (2,10),  raises RuntimeError

      :param target_shape: TODO

      :returns: TBoxTensor

      :raises RuntimeError: If space dimensions, ie. the last dimensions do not match.
      :raises RuntimeError: If cannot reshape the extra dimensions and torch.reshape raises.



